import * as path from 'path';

interface ParsedNotebook {
    cells: Array<{
        index: number;
        source: string;
        type: string;
    }>;
    imports: string[];
    files_read: string[];
    files_written: string[];
}

export function generateSnakefile(notebookName: string, data: ParsedNotebook): string {
    const codeCells = data.cells.filter(c => c.type === 'code');
    
    // Group cells into logical rules based on outputs
    const rules = createRules(codeCells, data.files_read, data.files_written);
    
    return `# Snakemake workflow generated from ${notebookName}.ipynb
# Generated by BioWorkflow Generator

# Configuration
configfile: "config.yaml"

# All output files
rule all:
    input:
${data.files_written.map(f => `        "${f}"`).join(',\n')}

${rules.map(rule => generateRule(rule)).join('\n\n')}
`;
}

interface Rule {
    name: string;
    input: string[];
    output: string[];
    script: string;
}

function createRules(codeCells: any[], filesRead: string[], filesWritten: string[]): Rule[] {
    const rules: Rule[] = [];
    
    // Find cells that produce outputs
    codeCells.forEach((cell, idx) => {
        const cellOutputs = filesWritten.filter(file => 
            cell.source.includes(file)
        );
        
        if (cellOutputs.length > 0) {
            const cellInputs = filesRead.filter(file => 
                cell.source.includes(file)
            );
            
            // Extract a meaningful name from the cell
            const firstLine = cell.source.split('\n')[0].replace(/^#\s*/, '');
            const ruleName = generateRuleName(firstLine, idx);
            
            rules.push({
                name: ruleName,
                input: cellInputs,
                output: cellOutputs,
                script: cell.source
            });
        }
    });
    
    // If no rules with outputs, create a processing rule
    if (rules.length === 0 && codeCells.length > 0) {
        rules.push({
            name: 'process_data',
            input: filesRead,
            output: filesWritten.length > 0 ? filesWritten : ['results/output.txt'],
            script: codeCells.map(c => c.source).join('\n\n')
        });
    }
    
    return rules;
}

function generateRuleName(description: string, index: number): string {
    // Convert description to snake_case rule name
    let name = description
        .toLowerCase()
        .replace(/[^a-z0-9\s]/g, '')
        .replace(/\s+/g, '_')
        .substring(0, 50);
    
    // Remove common prefixes
    name = name.replace(/^(import|define|load|calculate|filter|normalize|save|generate)\s*/g, '');
    
    // If name is empty or too short, use index
    if (name.length < 3) {
        name = `step_${index + 1}`;
    }
    
    return name;
}

function generateRule(rule: Rule): string {
    const hasInputs = rule.input.length > 0;
    const hasOutputs = rule.output.length > 0;
    
    return `rule ${rule.name}:
${hasInputs ? `    input:
${rule.input.map(f => `        "${f}"`).join(',\n')}` : ''}
${hasOutputs ? `    output:
${rule.output.map(f => `        "${f}"`).join(',\n')}` : ''}
    conda:
        "envs/environment.yaml"
    script:
        "scripts/${rule.name}.py"`;
}

export function generateConfigYaml(data: ParsedNotebook): string {
    return `# Configuration file for Snakemake workflow
# Modify paths and parameters as needed

# Input data paths
input_data:
${data.files_read.map(f => `  - "${f}"`).join('\n')}

# Output directory
output_dir: "results"

# Parameters
params:
  min_genes: 200
  min_cells: 3
  n_top_genes: 2000
`;
}

export function generateEnvironmentYaml(imports: string[]): string {
    // Map Python imports to conda packages
    const packageMap: { [key: string]: string } = {
        'scanpy': 'scanpy',
        'pandas': 'pandas',
        'numpy': 'numpy',
        'matplotlib.pyplot': 'matplotlib',
        'seaborn': 'seaborn',
        'pathlib.Path': 'python>=3.8',
        'anndata': 'anndata',
        'scipy': 'scipy',
        'sklearn': 'scikit-learn'
    };
    
    const packages = new Set<string>();
    packages.add('python>=3.8');
    
    imports.forEach(imp => {
        const baseImport = imp.split('.')[0];
        if (packageMap[imp]) {
            packages.add(packageMap[imp]);
        } else if (packageMap[baseImport]) {
            packages.add(packageMap[baseImport]);
        } else {
            packages.add(baseImport);
        }
    });
    
    return `name: bioworkflow
channels:
  - conda-forge
  - bioconda
  - defaults
dependencies:
${Array.from(packages).map(pkg => `  - ${pkg}`).join('\n')}
  - pip
  - pip:
    - nbformat
`;
}

export function createScriptFile(ruleName: string, script: string): string {
    return `#!/usr/bin/env python3
# Script for rule: ${ruleName}
# Generated by BioWorkflow Generator

${script}
`;
}
