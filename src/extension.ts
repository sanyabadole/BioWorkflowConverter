import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { execSync } from 'child_process';

export function activate(context: vscode.ExtensionContext) {
    console.log('=== BioWorkflow Generator Extension Activated! ===');
    
    let disposable = vscode.commands.registerCommand(
        'bio-workflow-generator.convertNotebook',
        async (uri: vscode.Uri) => {
            console.log('=== Command triggered! ===');
            
            // Get the notebook file path
            const notebookPath = uri.fsPath;
            
            if (!notebookPath.endsWith('.ipynb')) {
                vscode.window.showErrorMessage('Please select a Jupyter notebook (.ipynb) file');
                return;
            }
            
            vscode.window.showInformationMessage(`Processing: ${path.basename(notebookPath)}`);
            
            try {
                // Call Python parser script
                const pythonScript = path.join(context.extensionPath, 'python', 'parse_notebook.py');
                const result = execSync(`/Users/sanyabadole/Desktop/BioWorkflowConverter/bio-workflow-generator/python/venv/bin/python "${pythonScript}" "${notebookPath}"`, {
                    encoding: 'utf-8'
                });
                
                const parsedData = JSON.parse(result);
                
                // Create output folder
                const notebookDir = path.dirname(notebookPath);
                const notebookName = path.basename(notebookPath, '.ipynb');
                const outputDir = path.join(notebookDir, `${notebookName}_converted`);
                
                if (!fs.existsSync(outputDir)) {
                    fs.mkdirSync(outputDir);
                }
                
                // Write analysis results
                const analysisPath = path.join(outputDir, 'analysis.json');
                fs.writeFileSync(analysisPath, JSON.stringify(parsedData, null, 2));
                
                // Create a simple README
                const readmePath = path.join(outputDir, 'README.md');
                const readmeContent = generateReadme(notebookName, parsedData);
                fs.writeFileSync(readmePath, readmeContent);
                
                vscode.window.showInformationMessage(
                    `Conversion complete! Output in: ${outputDir}`
                );
                
                // Open the README file
                const readmeUri = vscode.Uri.file(readmePath);
                vscode.window.showTextDocument(readmeUri);
                
            } catch (error) {
                vscode.window.showErrorMessage(`Error: ${error}`);
            }
        }
    );
    
    context.subscriptions.push(disposable);
    console.log('=== Command registered: bio-workflow-generator.convertNotebook ===');
}

function generateReadme(notebookName: string, data: any): string {
    const codeCells = data.cells.filter((c: any) => c.type === 'code');
    const markdownCells = data.cells.filter((c: any) => c.type === 'markdown');
    
    // Group imports by category
    const bioinfoLibs = data.imports.filter((imp: string) => 
        ['scanpy', 'anndata', 'scvi', 'squidpy', 'pegasus'].some(lib => imp.includes(lib))
    );
    const dataLibs = data.imports.filter((imp: string) => 
        ['pandas', 'numpy', 'polars'].some(lib => imp.includes(lib))
    );
    const vizLibs = data.imports.filter((imp: string) => 
        ['matplotlib', 'seaborn', 'plotly'].some(lib => imp.includes(lib))
    );
    const otherLibs = data.imports.filter((imp: string) => 
        ![...bioinfoLibs, ...dataLibs, ...vizLibs].includes(imp)
    );
    
    return `# ${notebookName} - Converted Workflow

## ðŸ“Š Analysis Summary

- **Total Cells**: ${data.cells.length}
- **Code Cells**: ${codeCells.length}
- **Markdown Cells**: ${markdownCells.length}

## ðŸ“¦ Dependencies Detected

${bioinfoLibs.length > 0 ? `### Bioinformatics Libraries
${bioinfoLibs.map((imp: string) => `- ${imp}`).join('\n')}
` : ''}
${dataLibs.length > 0 ? `### Data Processing
${dataLibs.map((imp: string) => `- ${imp}`).join('\n')}
` : ''}
${vizLibs.length > 0 ? `### Visualization
${vizLibs.map((imp: string) => `- ${imp}`).join('\n')}
` : ''}
${otherLibs.length > 0 ? `### Other
${otherLibs.map((imp: string) => `- ${imp}`).join('\n')}
` : ''}

## ðŸ“‚ Data Flow

### Input Files (${data.files_read.length})
${data.files_read.length > 0 ? data.files_read.map((f: string) => `- \`${f}\``).join('\n') : 'None detected'}

### Output Files (${data.files_written.length})
${data.files_written.length > 0 ? data.files_written.map((f: string) => `- \`${f}\``).join('\n') : 'None detected'}

## ðŸ”„ Workflow Steps

${codeCells.map((cell: any, idx: number) => {
    const firstLine = cell.source.split('\n')[0].replace(/^#\s*/, '');
    return `${idx + 1}. ${firstLine || 'Processing step'}`;
}).join('\n')}

---

*Generated by BioWorkflow Generator v0.0.1*  
*Ready for conversion to Snakemake/Nextflow pipeline*
`;
}


export function deactivate() {}
